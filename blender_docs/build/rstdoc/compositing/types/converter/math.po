# Translations template for PROJECT.
# Copyright (C) 2019 ORGANIZATION
# This file is distributed under the same license as the PROJECT project.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PROJECT VERSION\n"
"Report-Msgid-Bugs-To: EMAIL@ADDRESS\n"
"POT-Creation-Date: 2019-11-27 19:50+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

# Nút Toán -- Math Node
msgid "Math Node"
msgstr "Nút Toán"

msgid "Math node."
msgstr "Nút Toán."

# The *Nút Toán -- Math Node* performs math operations.
msgid "The *Math Node* performs math operations."
msgstr "*Nút Toán* (Math Node) thực hiện các phép toán."

# Đầu Vào -- Inputs
msgid "Inputs"
msgstr "Đầu Vào"

# Giá Trị -- Value
msgid "Value"
msgstr "Giá Trị"

msgid "First numerical value. The trigonometric functions accept values in radians."
msgstr "Giá trị số đầu tiên. Các hàm lượng giác chấp nhận các giá trị theo đơn vị rad."

# Second numerical value. This value is **đảo nghịch -- not** used in functions that accept only one parameter like the trigonometric functions, Round and Absolute.
msgid "Second numerical value. This value is **not** used in functions that accept only one parameter like the trigonometric functions, Round and Absolute."
msgstr "Giá trị số thứ hai. Giá trị này **không** được sử dụng trong các hàm chỉ chấp nhận một tham số, như các hàm lượng giác, hàm Làm Tròn Số (Round) và hàm tính số Tuyệt Đối (Absolute)."

# Tính Chất -- Properties
msgid "Properties"
msgstr "Tính Chất"

# Thao Tác -- Operation
msgid "Operation"
msgstr "Thao Tác"

# Add, Subtract, Multiply, Divide, Sine, Cosine, Tangent, Arcsine, Arccosine, Arctangent, Arctangent2, Power, Logarithm, Minimum, Maximum, Round, Less Than, Greater Than, Modulo, Absolute
msgid "Add, Subtract, Multiply, Divide, Sine, Cosine, Tangent, Arcsine, Arccosine, Arctangent, Arctangent2, Power, Logarithm, Minimum, Maximum, Round, Less Than, Greater Than, Modulo, Absolute"
msgstr "Cộng, Trừ, Nhân, Chia, Sin, Cos, Tang, Arcsin, Arccos, Arctan, Arctan2, Lũy Thừa, Logarit, Tối Thiểu, Tối Đa, Tròn, Nhỏ Hơn, Lớn Hơn, Modulo, Tuyệt Đối"

# Hạn Định -- Clamp
msgid "Clamp"
msgstr "Hạn Định"

# Limits the output to the range (0 to 1). See :term:`hạn định -- clamp`.
msgid "Limits the output to the range (0 to 1). See :term:`clamp`."
msgstr "Giới hạn đầu ra nằm trong phạm vi (0 đến 1). Xin xem :term:`clamp`."

# Đầu Ra -- Outputs
msgid "Outputs"
msgstr "Đầu Ra"

msgid "Numerical value output."
msgstr "Giá trị số cung cấp ở đầu ra."

# Ví Dụ -- Examples
msgid "Examples"
msgstr "Ví Dụ"

# Chắn Lọc Z Thủ Công -- Manual Z-Mask
msgid "Manual Z-Mask"
msgstr "Chắn Lọc Z Thủ Công"

msgid "Minimum and maximum function example."
msgstr "Minimum and maximum function example."

msgid "This example has one scene input by the top *Render Layers* node, which has a cube that is about 10 units from the camera. The bottom *Render Layers* node inputs a scene with a plane that covers the left half of the view and is 7 units from the camera. Both are fed through their respective *Map Value* nodes to divide the Z-buffer by 20 (multiply by 0.05, as shown in the Size field) and clamped to be a min/max of 0.0/1.0 respectively."
msgstr "This example has one scene input by the top *Tầng Kết Xuất -- Render Layers*-- Render Layers* node, which has a cube that is about 10 units from the camera. The bottom *Render Layers* node inputs a scene with a plane that covers the left half of the view and is 7 units from the camera. Both are fed through their respective *Ánh Xạ Giá Trị -- Map Value* nodes to divide the Z-buffer by 20 (multiply by 0.05, as shown in the Size field) and clamped to be a min/max of 0.0/1.0 respectively."

msgid "For the minimum function, the node selects those Z values where the corresponding pixel is closer to the camera; so it chooses the Z values for the plane and part of the cube. The background has an infinite Z value, so it is clamped to 1.0 (shown as white). In the maximum example, the Z values of the cube are greater than the plane, so they are chosen for the left side, but the plane *Render Layers* Z are infinite (mapped to 1.0) for the right side, so they are chosen."
msgstr "For the minimum function, the node selects those Z values where the corresponding pixel is closer to the camera; so it chooses the Z values for the plane and part of the cube. The background has an infinite Z value, so it is clamped to 1.0 (shown as white). In the maximum example, the Z values of the cube are greater than the plane, so they are chosen for the left side, but the plane *Tầng Kết Xuất -- Render Layers* Z are infinite (mapped to 1.0) for the right side, so they are chosen."

# Dùng Hàm Sin để Tạo Xung -- Using Sine Function to Pulsate
msgid "Using Sine Function to Pulsate"
msgstr "Dùng Hàm Sin để Tạo Xung"

msgid "Using sine function example."
msgstr "Using sine function example."

msgid "This example has a *Time* node putting out a linear sequence from 0 to 1 over the course of 101 frames. At frame 25, the output value is 0.25. That value is multiplied by 2 × pi (6.28) and converted to 1.0 by the Sine function, since we all know that :math:`sin(2 × pi/ 4) = sin(pi/ 2) = +1.0`."
msgstr "This example has a *Thời Gian -- Time* node putting out a linear sequence from 0 to 1 over the course of 101 frames. At frame 25, the output value is 0.25. That value is multiplied by 2 × pi (6.28) and converted to 1.0 by the Sine function, since we all know that :math:`sin(2 × pi/ 4) = sin(pi/ 2) = +1.0`."

msgid "Since the sine function can put out values between (-1.0 to 1.0), the *Map Value* node scales that to 0.0 to 1.0 by taking the input (-1 to 1), adding 1 (making 0 to 2), and multiplying the result by one-half (thus scaling the output between 0 to 1). The default *Color Ramp* converts those values to a gray-scale. Thus, medium gray corresponds to a 0.0 output by the sine, black to -1.0, and white to 1.0. As you can see, :math:`sin(pi/ 2) = 1.0`. Like having your own visual color calculator! Animating this node setup provides a smooth cyclic sequence through the range of grays."
msgstr "Since the sine function can put out values between (-1.0 to 1.0), the *Ánh Xạ Giá Trị -- Map Value* node scales that to 0.0 to 1.0 by taking the input (-1 to 1), adding 1 (making 0 to 2), and multiplying the result by one-half (thus scaling the output between 0 to 1). The default *Dốc Màu -- Color Ramp* converts those values to a gray-scale. Thus, medium gray corresponds to a 0.0 output by the sine, black to -1.0, and white to 1.0. As you can see, :math:`sin(pi/ 2) = 1.0`. Like having your own visual color calculator! Animating this node setup provides a smooth cyclic sequence through the range of grays."

msgid "Use this function to vary, for example, the alpha channel of an image to produce a fading in/out effect. Alter the Z channel to move a scene in/out of focus. Alter a color channel value to make a color \"pulse\"."
msgstr "Use this function to vary, for example, the alpha channel of an image to produce a fading in/out effect. Alter the Z channel to move a scene in/out of focus. Alter a color channel value to make a color \"pulse\"."

# Làm Sáng (Đổi Tỷ Lệ) một Kênh -- Brightening (Scaling) a Channel
msgid "Brightening (Scaling) a Channel"
msgstr "Làm Sáng (Đổi Tỷ Lệ) một Kênh"

msgid "Scaling a channel example."
msgstr "Scaling a channel example."

msgid "This example has a *Math (Multiply)* node increasing the luminance channel (Y) of the image to make it brighter. Note that you should use a *Map Value node* with min() and max() enabled to clamp the output to valid values. With this approach, you could use a logarithmic function to make a high dynamic range image. For this particular example, there is also a *Bright/Contrast node* that might give simpler control over brightness."
msgstr "This example has a *Math (Multiply)* node increasing the luminance channel (Y) of the image to make it brighter. Note that you should use a *Nút Ánh Xạ Giá Trị -- Map Value node* with min() and max() enabled to clamp the output to valid values. With this approach, you could use a logarithmic function to make a high dynamic range image. For this particular example, there is also a *Bright/Contrast node* that might give simpler control over brightness."

# Hạn Chế Sự Lựa Chọn Màu Sắc (Áp Phích Hóa) -- Restrict Color Selection (Posterization) -- Restrict Color Selection (Posterization)
msgid "Restrict Color Selection (Posterization)"
msgstr "Hạn Chế Sự Lựa Chọn Màu Sắc (Áp Phích Hóa) -- Restrict Color Selection (Posterization)"

msgid "Posterization example."
msgstr "Posterization example."

msgid "In this example, we restrict the color values to be one of the six values: 0, 0.2, 0.4, 0.6, 0.8, 1."
msgstr "In this example, we restrict the color values to be one of the six values: 0, 0.2, 0.4, 0.6, 0.8, 1."

msgid "To split up a continuous range of values between 0 and 1 to certain set of values, the following function is used: :math:`round(x × n - 0.5) / (n - 1)`, where \"n\" is the number of possible output values, and \"x\" is the input pixel color. `Read more about this function <https://en.blender.org/index.php/Doc:2.4/Manual/Composite_Nodes/Types/Convertor#Quantize.2FRestrict_Color_Selection>`__."
msgstr "To split up a continuous range of values between 0 and 1 to certain set of values, the following function is used: :math:`round(x × n - 0.5) / (n - 1)`, where \"n\" is the number of possible output values, and \"x\" is the input pixel color. `Read more about this function <https://en.blender.org/index.php/Doc:2.4/Manual/Composite_Nodes/Types/Convertor#Quantize.2FRestrict_Color_Selection>`__."

msgid "To implement this function in Blender, consider the node setup above. We string the math nodes into a function that takes each color (values from 0 to 1), multiplies it up by six, the desired number of divisions (values become from 0 to 6), offsets it by 0.5 (-0.5 to 5.5), rounds the value to the nearest whole number (produces 0, 1, 2, 3, 4, 5), and then divides the image pixel color by five (0.0, 0.2, 0.4, 0.6, 0.8, 1.0)."
msgstr "To implement this function in Blender, consider the node setup above. We string the math nodes into a function that takes each color (values from 0 to 1), multiplies it up by six, the desired number of divisions (values become from 0 to 6), offsets it by 0.5 (-0.5 to 5.5), rounds the value to the nearest whole number (produces 0, 1, 2, 3, 4, 5), and then divides the image pixel color by five (0.0, 0.2, 0.4, 0.6, 0.8, 1.0)."

msgid "In the case of a color image, you need split it into separate RGB channels using *Separate/Combine RGBA* nodes and perform this operation on each channel independently."
msgstr "In the case of a color image, you need split it into separate RGB channels using *Separate/Combine RGBA* nodes and perform this operation on each channel independently."

