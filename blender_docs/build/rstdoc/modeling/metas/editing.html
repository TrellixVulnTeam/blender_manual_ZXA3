<document source="/home/htran/blender_documentations/blender_docs/manual/modeling/metas/editing.rst">
 <target refid="meta-ball-editing">
 </target>
 <section ids="editing meta-ball-editing" names="editing meta-ball-editing">
  <title>
   Editing
  </title>
  <paragraph>
   In addition to having several meta objects in a same family,
you can also have several meta primitives in a single object (just add some more while in Edit Mode).
Each will be an element, with its own shape, editing rings (in the viewport), and settings.
  </paragraph>
  <section ids="active-element" names="active\ element">
   <title>
    Active Element
   </title>
   <admonition classes="refbox">
    <title>
     Reference
    </title>
    <field_list>
     <field>
      <field_name>
       Mode
      </field_name>
      <field_body>
       <paragraph>
        Edit Mode
       </paragraph>
      </field_body>
     </field>
     <field>
      <field_name>
       Panel
      </field_name>
      <field_body>
       <paragraph>
        <inline classes="menuselection" rawtext=":menuselection:`Properties editor --&gt; Metaball --&gt; Active Element`">
         Properties editor ‣ Metaball ‣ Active Element
        </inline>
       </paragraph>
      </field_body>
     </field>
    </field_list>
   </admonition>
   <figure align="right" ids="id1">
    <image candidates="{'*': 'images/modeling_metas_properties_active-element-panel.png'}" uri="images/modeling_metas_properties_active-element-panel.png"/>
    <caption>
     Active Element panel.
    </caption>
   </figure>
   <paragraph>
    These settings apply only to the selected meta element.
   </paragraph>
   <definition_list>
    <definition_list_item>
     <term>
      Type
     </term>
     <definition>
      <paragraph>
       Changes the
       <reference internal="True" refuri="">
        <inline classes="doc">
         primitive shape
        </inline>
       </reference>
       of the meta object.
      </paragraph>
     </definition>
    </definition_list_item>
    <definition_list_item>
     <term>
      Stiffness
     </term>
     <definition>
      <paragraph>
       Controls the influence range for individual meta elements, unlike
       <emphasis>
        Influence Threshold
       </emphasis>
       which controls the influence for the entire
       <reference internal="True" refid="meta-ball-object-families">
        <inline classes="std std-ref">
         meta family
        </inline>
       </reference>
       .
This essentially defines how sensitive a meta is to being affected by other metas.
With a low stiffness, the meta will begin to deform from further away.
A higher value means the meta needs to be close to another one to begin merging.
The
       <emphasis>
        Stiffness
       </emphasis>
       is visualized by the
       <emphasis>
        green ring
       </emphasis>
       and can be selected and
       <reference internal="True" refuri="#bpy-ops-transform-resize">
        <inline classes="std std-ref">
         scaled
        </inline>
       </reference>
       to also changes the
       <emphasis>
        Stiffness
       </emphasis>
       value.
      </paragraph>
      <paragraph>
       To be visible, the
       <emphasis>
        Stiffness
       </emphasis>
       must be slightly larger than the
       <emphasis>
        Threshold
       </emphasis>
       value.
      </paragraph>
      <target refid="fig-meta-edit-stiffness">
      </target>
      <figure align="center" ids="id2 fig-meta-edit-stiffness" names="fig-meta-edit-stiffness">
       <image candidates="{'*': 'images/modeling_metas_editing_stiffness.png'}" uri="images/modeling_metas_editing_stiffness.png" width="450px"/>
       <caption>
        The left meta ball, has a smaller
        <emphasis>
         Stiffness
        </emphasis>
        value than the right one.
       </caption>
      </figure>
     </definition>
    </definition_list_item>
    <definition_list_item>
     <term>
      Radius
     </term>
     <definition>
      <paragraph>
       Controls the physical size of the metaball.
This works the same as scaling the metaball in Object Mode.
The
       <emphasis>
        Radius
       </emphasis>
       is visualized by the
       <emphasis>
        white ring
       </emphasis>
       and can be selected and
       <reference internal="True" refuri="#bpy-ops-transform-resize">
        <inline classes="std std-ref">
         scaled
        </inline>
       </reference>
       to also changes the
       <emphasis>
        Radius
       </emphasis>
       value.
      </paragraph>
     </definition>
    </definition_list_item>
   </definition_list>
   <target refid="meta-ball-editing-negative-influence">
   </target>
   <definition_list ids="meta-ball-editing-negative-influence" names="meta-ball-editing-negative-influence">
    <definition_list_item>
     <term>
      Negative
     </term>
     <definition>
      <paragraph>
       Controls whether the influence is
       <emphasis>
        positive
       </emphasis>
       or
       <emphasis>
        negative
       </emphasis>
       .
      </paragraph>
      <paragraph>
       A
       <emphasis>
        positive
       </emphasis>
       influence is defined as an attraction,
meaning that the meshes will stretch towards each other as the
       <emphasis>
        rings of influence
       </emphasis>
       intersect.
The opposite effect would be a
       <emphasis>
        negative
       </emphasis>
       influence where the objects repel each other.
      </paragraph>
      <note>
       <paragraph>
        If a metaball has
        <emphasis>
         Negative
        </emphasis>
        influence the meta is not visible in the 3D Viewport,
only the surrounding circles are shown.
       </paragraph>
      </note>
      <table>
       <tgroup cols="2">
        <colspec colwidth="50">
        </colspec>
        <colspec colwidth="50">
        </colspec>
        <tbody>
         <row>
          <entry>
           <figure ids="id3">
            <image candidates="{'*': 'images/modeling_metas_editing_family.png'}" uri="images/modeling_metas_editing_family.png"/>
            <caption>
             Positive influence of three meta balls.
            </caption>
           </figure>
          </entry>
          <entry>
           <figure ids="id4">
            <image candidates="{'*': 'images/modeling_metas_editing_negative-influence.png'}" uri="images/modeling_metas_editing_negative-influence.png"/>
            <caption>
             Negative influence of a meta ball;
the first is negative and the second positive.
            </caption>
           </figure>
          </entry>
         </row>
        </tbody>
       </tgroup>
      </table>
     </definition>
    </definition_list_item>
    <definition_list_item>
     <term>
      Hide
     </term>
     <definition>
      <paragraph>
       As in
       <reference internal="True" refuri="#object-show-hide">
        <inline classes="std std-ref">
         Show/Hide
        </inline>
       </reference>
       in Object Mode, you can hide the selected meta(s),
and then reveal what was hidden. This is very handy for cleaning your views up a bit.
      </paragraph>
      <note>
       <bullet_list bullet="-">
        <list_item>
         <paragraph>
          Hiding a meta does not
          <emphasis>
           only
          </emphasis>
          hide it, but also disables it from the meta computation,
which will affect the final geometry.
         </paragraph>
        </list_item>
        <list_item>
         <paragraph>
          The two red and green rings always remain visible in Edit Mode,
as well as the select circle in Object Mode.
         </paragraph>
        </list_item>
       </bullet_list>
      </note>
     </definition>
    </definition_list_item>
   </definition_list>
  </section>
  <section ids="deleting-elements" names="deleting\ elements">
   <title>
    Deleting Elements
   </title>
   <admonition classes="refbox">
    <title>
     Reference
    </title>
    <field_list>
     <field>
      <field_name>
       Hotkey
      </field_name>
      <field_body>
       <paragraph>
        <literal classes="kbd">
         X
        </literal>
        ,
        <literal classes="kbd">
         Delete
        </literal>
       </paragraph>
      </field_body>
     </field>
    </field_list>
   </admonition>
   <paragraph>
    You can only delete the active element, no fancy options here.
   </paragraph>
  </section>
  <section ids="conversion" names="conversion">
   <title>
    Conversion
   </title>
   <paragraph>
    To convert the meta to a real mesh, use
    <reference internal="True" refuri="#object-convert-to">
     <inline classes="std std-ref">
      Convert To
     </inline>
    </reference>
    in Object Mode.
   </paragraph>
   <target refid="meta-ball-object-families">
   </target>
  </section>
  <section ids="object-families meta-ball-object-families" names="object\ families meta-ball-object-families">
   <title>
    Object Families
   </title>
   <paragraph>
    A “family” is a way to regroup several meta objects,
producing something very similar to having several metas inside the same object.
   </paragraph>
   <paragraph>
    It is defined by the left part of an object’s name (the one before the first dot).
Remember, an object’s name is the one in the
    <emphasis>
     Object Name
    </emphasis>
    field, in most panels,
    <strong>
     not
    </strong>
    the
    <emphasis>
     Metaball Name
    </emphasis>
    field, which is the meta data-block’s name…
For example, the
    <emphasis>
     family
    </emphasis>
    part of “MetaPlane.001” is
    <literal>
     MetaPlane
    </literal>
    .
Each meta object in the same “family” is associated with one another as discussed below.
   </paragraph>
   <figure align="center" ids="id5">
    <image candidates="{'*': 'images/modeling_metas_editing_family.png'}" uri="images/modeling_metas_editing_family.png" width="450px"/>
    <caption>
     Metaball family.
    </caption>
   </figure>
   <paragraph>
    Families of metas are controlled by a
    <emphasis>
     base
    </emphasis>
    meta object which is identified by
an object name
    <strong>
     without
    </strong>
    a dot in it. For example,
if we have three metas called
    <literal>
     MetaThing
    </literal>
    ,
    <literal>
     MetaThing.001
    </literal>
    ,
    <literal>
     MetaThing.round
    </literal>
    , the
    <emphasis>
     base
    </emphasis>
    meta object would be
    <literal>
     MetaThing
    </literal>
    .
   </paragraph>
   <paragraph>
    The
    <emphasis>
     base
    </emphasis>
    meta object determines the basis, the resolution, the threshold,
    <emphasis>
     and
    </emphasis>
    the transformations. It also has the material and texture area.
In a way, the
    <emphasis>
     base
    </emphasis>
    meta is the “owner” of the other metas in the family
(i.e. it is as if the other metas were “included” or joined into the base one).
   </paragraph>
   <hint>
    <paragraph>
     When working with multiple scenes,
take care naming your meta objects so the
     <emphasis>
      base
     </emphasis>
     is always in the same scene as other metas.
    </paragraph>
    <paragraph>
     Failing to do so will give confusing behaviors (like invisible meta objects).
    </paragraph>
   </hint>
  </section>
  <section ids="examples" names="examples">
   <title>
    Examples
   </title>
   <paragraph>
    Fig.
    <reference internal="True" refid="fig-meta-ball-base">
     <inline classes="std std-ref">
      Meta ball base.
     </inline>
    </reference>
    shows the
    <emphasis>
     base
    </emphasis>
    meta labeled “B”.
The other two
    <emphasis>
     Meta
    </emphasis>
    objects are
    <emphasis>
     children
    </emphasis>
    . Children’s selection rings are always black,
while the group’s mesh is orange. Because the metas are grouped,
they form a unified mesh which can always be selected by selecting the mesh of any meta in the group.
   </paragraph>
   <target refid="fig-meta-ball-base">
   </target>
   <figure align="center" ids="id6 fig-meta-ball-base" names="fig-meta-ball-base">
    <image candidates="{'*': 'images/modeling_metas_editing_base-example.png'}" uri="images/modeling_metas_editing_base-example.png" width="450px"/>
    <caption>
     Meta ball base.
    </caption>
   </figure>
   <paragraph>
    For example, in Fig.
    <reference internal="True" refid="fig-meta-ball-base">
     <inline classes="std std-ref">
      Meta ball base.
     </inline>
    </reference>
    , only the lower sphere (the parent) has been selected,
and you see that both the parent’s mesh
    <emphasis>
     and
    </emphasis>
    all of the children’s meshes are now highlighted.
   </paragraph>
   <target refid="fig-meta-ball-scale">
   </target>
   <figure align="center" ids="id7 fig-meta-ball-scale" names="fig-meta-ball-scale">
    <image candidates="{'*': 'images/modeling_metas_editing_base-example-scale.png'}" uri="images/modeling_metas_editing_base-example-scale.png" width="450px"/>
    <caption>
     Scaling the “base”.
    </caption>
   </figure>
   <paragraph>
    The
    <emphasis>
     base
    </emphasis>
    meta object controls the
    <emphasis>
     polygonalization
    </emphasis>
    (mesh structure) for the group, and
as such, also controls the polygonalization for the children (non-base) metas.
If we transform the
    <emphasis>
     base
    </emphasis>
    meta, the children’s polygonalization changes.
However, if we transform the children, the polygonalization remains unchanged.
   </paragraph>
   <hint>
    <paragraph>
     This discussion of “polygonization” does
     <emphasis>
      not
     </emphasis>
     mean that the various meshes do not deform
towards or away from each other (meta objects always influence one another in the usual way,
within a same family).
    </paragraph>
    <paragraph>
     Rather, it means that the underlying mesh structure changes only when the
     <emphasis>
      base
     </emphasis>
     object transforms.
For example, if you scale the
     <emphasis>
      base
     </emphasis>
     , the children’s mesh structure changes.
    </paragraph>
    <paragraph>
     In Fig.
     <reference internal="True" refid="fig-meta-ball-scale">
      <inline classes="std std-ref">
       Scaling the “base”.
      </inline>
     </reference>
     , the
     <emphasis>
      base
     </emphasis>
     has been scaled down,
which has the effect of scaling the mesh structure of each of the children. As you can see,
the children’s mesh resolution has increased, while the
     <emphasis>
      base
     </emphasis>
     decreased.
The children did
     <emphasis>
      not
     </emphasis>
     change size!
    </paragraph>
   </hint>
  </section>
 </section>
</document>