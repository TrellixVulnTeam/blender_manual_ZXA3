# SOME DESCRIPTIVE TITLE.
# Copyright (C) : This page is licensed under a CC-BY-SA 4.0 Int. License
# This file is distributed under the same license as the Blender 2.79 Manual
# package.
# Hoang Duy Tran <hoangduytran1960@gmail.com>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Blender 2.8 Manual 2.8\n"
"Report-Msgid-Bugs-To: EMAIL@ADDRESS\n"
"POT-Creation-Date: 2019-07-17 21:45+0100\n"
"PO-Revision-Date: 2020-03-01 04:03+0000\n"
"Last-Translator: Hoang Duy Tran <hoangduytran1960@gmail.com>\n"
"Language: vi\n"
"Language-Team: London, UK <hoangduytran1960@gmail.com>\n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

msgid "Python Scripting Mode"
msgstr "Chế Độ Tập Lệnh Python -- Python Scripting Mode"

msgid ""
"The Python Scripting mode offers full programmable line stylizes. In this"
" control mode, all styling operations are written as Python scripts "
"referred to as style modules in the Freestyle terminology. The input to a"
" style module is a view map (i.e. a set of detected feature edges), and "
"the output is a set of stylized strokes."
msgstr ""
"The Python Viết Tập Lệnh chế độ offers toàn phần programmable đường "
"thẳng/dòng stylizes. Vào cái/điều này điều khiển chế độ, toàn bộ styling "
"các thao tác là written tựa như Python tập lệnh referred tới tựa như kiểu"
" modules vào the Phong Cách Tự Do terminology. The đầu vào tới a kiểu "
"mô-đun là a góc nhìn ánh xạ (i.e. a đặt của detected chức năng/nét đặc "
"trưng cạnh), và the đầu ra là a đặt của stylized nét vẽ."

msgid ""
"A style module is composed of successive calls of five basic operators: "
"selection, chaining, splitting, sorting and stroke creation. The "
"selection operator identifies a subset of input feature edges based on "
"one or more user-defined selection conditions (predicates). The selected "
"edges are processed with the chaining, splitting and sorting operators to"
" build chains of feature edges. These operators are also controlled by "
"user-supplied predicates and functions in order to determine how to "
"transform the feature edges into chains. Finally, the chains are "
"transformed into stylized strokes by the stroke creation operator, which "
"takes a list of user-defined stroke shaders."
msgstr ""
"A kiểu mô-đun là composed của successive calls của năm đơn giản thao tác:"
" lựa chọn, chuyền nối, tách phân, sắp thứ tự và nét vẽ sự kiến tạo. The "
"lựa chọn thao tác identifies a tập hợp con của đầu vào chức năng/nét đặc "
"trưng cạnh dựa trêm nền tảng bật một hoặc nhiều/lớn hơn user-defined lựa "
"chọn conditions (predicates). The cái được chọn cạnh là processed với the"
" chuyền nối, tách phân và sắp thứ tự thao tác tới xây dựng chains của "
"chức năng/nét đặc trưng cạnh. Những Điều/Cái/Việc Này thao tác là also "
"điều khiển bằng cách user-supplied predicates và các hàm vào theo thứ tự "
"tới determine phương pháp/thế nào tới biến hóa the chức năng/nét đặc "
"trưng cạnh vào/trở thành chains. Finally, the chains là transformed "
"vào/trở thành stylized nét vẽ bằng cách the nét vẽ sự kiến tạo thao tác, "
"cái mà/tức takes a liệt kê của user-defined nét vẽ bộ tô bóng."

msgid ""
"Python style modules are stored within blend-files as text data-blocks. "
"External style module files first need to be loaded in the Text Editor. "
"Then the select menu within an entry of the style module stack allows you"
" to select a module from the list of loaded style modules."
msgstr ""
"Python kiểu modules là lưu within blend-files tựa như văn bản khối dữ "
"liệu. Bên Ngoài kiểu mô-đun tập tin đầu tiên/thứ nhất cần thiết tới "
"được/là loaded vào the Văn Bản Trình Biên Soạn. Rồi/Sau Đó the chọn trình"
" đơn within một entry của the kiểu mô-đun stack cho phép bạn tới chọn a "
"mô-đun từ the liệt kê của loaded kiểu modules."

msgid ""
"A screen capture of a style module ``cartoon.py`` loaded in the Text "
"Editor (left), as well as Freestyle options in the Python Scripting mode "
"in the View Layers buttons (right)."
msgstr ""
"A screen capture of a style module ``cartoon.py`` loaded in the Text "
"Editor (trái -- left), as well as Freestyle options in the Python "
"Scripting mode in the View Layers buttons (phải -- right)."

msgid ""
"Freestyle for Blender comes with a number of Python style modules that "
"can serve as a starting point of your own style module writing. See also "
"the section of the Freestyle Python API in the Blender Python API "
"reference manual for the full detail of style module constructs."
msgstr ""
"Phong Cách Tự Do dành cho/đối với/để Blender comes với a số/lượng của "
"Python kiểu modules đó/mà có thể serve tựa như a khởi đầu điểm/chấm của "
"của bạn của bản thân/sở hữu kiểu mô-đun viết/ghi. Xin Xem also the phần "
"của the Phong Cách Tự Do Python API vào the Blender Python API tham chiếu"
" thủ công/sách hướng dẫn sử dụng dành cho/đối với/để the toàn phần chi "
"tiết của kiểu mô-đun các cấu trúc."

msgid ""
"By T.K. using the Python Scripting mode (`blend-file "
"<https://wiki.blender.org/wiki/File:Turning_Pages.zip>`__, CC0)."
msgstr ""
"By T.K. using the Python Scripting mode (`blend-file -- blend-file "
"<https://wiki.blender.org/wiki/File:Turning_Pages.zip>`__, CC0)."

msgid ""
"By T.K. using the Python Scripting mode (`blend-file "
"<https://wiki.blender.org/wiki/File:Lily_Broken_Topology.zip>`__, CC0)."
msgstr ""
"By T.K. using the Python Scripting mode (`blend-file -- blend-file "
"<https://wiki.blender.org/wiki/File:Lily_Broken_Topology.zip>`__, CC0)."

msgid "Writing Style Modules"
msgstr "Viết/Ghi Kiểu Modules -- Writing Style Modules"

msgid ""
"A style module is a piece of code responsible for the stylization of "
"Freestyle line drawing. The input of a style module is a set of feature "
"edges called view map (ViewMap). The output is a set of stylized lines "
"also referred to as strokes. A style module is structured as a pipeline "
"of operations that allow for building strokes from the input edges within"
" the view map."
msgstr ""
"A kiểu mô-đun là a piece của mã nguồn chịu trách nhiệm dành cho/đối "
"với/để the stylization của Phong Cách Tự Do đường thẳng/dòng vẽ. The đầu "
"vào của a kiểu mô-đun là a đặt của chức năng/nét đặc trưng cạnh called "
"góc nhìn ánh xạ (ViewMap). The đầu ra là a đặt của stylized (số) đường "
"kẻ/thẳng/dòng also referred tới tựa như nét vẽ. A kiểu mô-đun là "
"structured tựa như a quy trình của các thao tác đó/mà cho phép dành "
"cho/đối với/để xây dựng/biên dịch nét vẽ từ the đầu vào cạnh within the "
"góc nhìn ánh xạ."

msgid ""
"There are five kinds of operations (listed with corresponding operator "
"functions):"
msgstr ""
"Kia/Có là năm kinds của các thao tác (listed với tương ứng thao tác các "
"hàm):"

msgid "Selection ``Operators.select()``"
msgstr "Selection ``Thao Tác.chọn() -- Operators.select()``"

msgid "Chaining ``Operators.chain(), Operators.bidirectional_chain()``"
msgstr ""
"Chaining ``Thao Tác.chain(), Thao Tác.bidirectional_chain() -- "
"Operators.chain(), Operators.bidirectional_chain()``"

msgid "Splitting ``Operators.sequential_split(), Operators.recursive_split()``"
msgstr ""
"Splitting ``Thao Tác.sequential_split(), Thao Tác.recursive_split() -- "
"Operators.sequential_split(), Operators.recursive_split()``"

msgid "Sorting ``Operators.sort()``"
msgstr "Sorting ``Thao Tác.sắp thứ tự() -- Operators.sort()``"

msgid "Stroke creation ``Operators.create()``"
msgstr "Stroke creation ``Thao Tác.kiến tạo() -- Operators.create()``"

msgid ""
"The input view map is populated with a set of ViewEdge objects. The "
"selection operation is used to pick up ViewEdges of interest to artists "
"based on user-defined selection conditions (predicates). Chaining "
"operations take the subset of ViewEdges and build Chains by concatenating"
" ViewEdges according to user-defined predicates and functions. The Chains"
" can be further refined by splitting them into smaller pieces (e.g. at "
"points where edges make an acute turn) and selecting a fraction of them "
"(e.g. to keep only those longer than a length threshold). The sorting "
"operation is used to arrange the stacking order of chains to draw one "
"line on top of another. The chains are finally transformed into stylized "
"strokes by the stroke creation operation applying a series of stroke "
"shaders to individual chains."
msgstr ""
"The đầu vào góc nhìn ánh xạ là populated với a đặt của ViewEdge vật thể. "
"The lựa chọn thao tác là sử dụng tới chọn lên/trên ViewEdges của interest"
" tới artists dựa trêm nền tảng bật user-defined lựa chọn conditions "
"(predicates). Chuyền Nối các thao tác take the tập hợp con của ViewEdges "
"và xây dựng Chains bằng cách concatenating ViewEdges according tới user-"
"defined predicates và các hàm. The Chains có thể được/là sâu/xa hơn "
"refined bằng cách tách phân chúng/họ vào/trở thành smaller pieces (e.g. "
"tại số điểm trong đó cạnh tạo một acute turn) và lựa chọn a phân số của "
"chúng/họ (e.g. tới duy trì duy/chỉ those longer than a chiều dài ngưỡng)."
" The sắp thứ tự thao tác là sử dụng tới arrange the stacking theo thứ tự "
"của chains tới vẽ một đường thẳng/dòng bật trên/đỉnh của một cái/điều "
"khác. The chains là finally transformed vào/trở thành stylized nét vẽ "
"bằng cách the nét vẽ sự kiến tạo thao tác applying a series của nét vẽ bộ"
" tô bóng tới cá nhân chains."

msgid ""
"ViewEdges, Chains and Strokes are generically referred to as one-"
"dimensional (1D) elements. A 1D element is a polyline that is a series of"
" connected straight lines. Vertices of 1D elements are called 0D elements"
" in general."
msgstr ""
"ViewEdges, Chains và Nét Vẽ là generically referred tới tựa như one-"
"dimensional (1D) phần tử. A 1D element là a đường đa giác đó/mà là a "
"series của kết nối thẳng (số) đường kẻ/thẳng/dòng. Điểm Đỉnh của 1D phần "
"tử là called 0D phần tử vào chung chung."

msgid ""
"All the operators act on a set of active 1D elements. The initial active "
"set is the set of ViewEdges in the input view map. The active set is "
"updated by the operators."
msgstr ""
"Toàn Bộ the thao tác hành động/cư xử bật a đặt của đang/hoạt động 1D phần"
" tử. The khởi đầu đang/hoạt động đặt là the đặt của ViewEdges vào the đầu"
" vào góc nhìn ánh xạ. The đang/hoạt động đặt là updated bằng cách the "
"thao tác."

msgid "Selection"
msgstr "Lựa Chọn -- Selection"

msgid ""
"The selection operator goes through every element of the active set and "
"keeps only the ones satisfying a certain predicate. The "
"``Operators.select()`` method takes as the argument a unary predicate "
"that works on any ``Interface1D`` that represents a 1D element. For "
"example::"
msgstr ""
"The selection operator goes through every element of the active set and "
"keeps only the ones satisfying a certain predicate. The ``Thao Tác.chọn()"
" -- Operators.select()`` method takes as the argument a unary predicate "
"that works on any ``Interface1D -- Interface1D`` that represents a 1D "
"element. For example::"

msgid ""
"This selection operation uses the ``QuantitativeInvisibilityUP1D`` "
"predicate to select only the visible ``ViewEdge`` (more precisely, those "
"whose quantitative invisibility is equal to 0). The selection operator is"
" intended to selectively apply the style to a fraction of the active 1D "
"elements."
msgstr ""
"This selection operation uses the ``QuantitativeInvisibilityUP1D -- "
"QuantitativeInvisibilityUP1D`` predicate to select only the visible "
"``ViewEdge -- ViewEdge`` (nhiều/lớn hơn precisely, those whose "
"quantitative invisibility là bằng nhau tới 0 -- more precisely, those "
"whose quantitative invisibility is equal to 0). The selection operator is"
" intended to selectively apply the style to a fraction of the active 1D "
"elements."

msgid ""
"It is noted that ``QuantitativeInvisibilityUP1D`` is a class implementing"
" the predicate that tests line visibility, and the ``Operators.select()``"
" method takes an instance of the predicate class as argument. The testing"
" of the predicate for a given 1D element is actually done by calling the "
"predicate instance, that is, by invoking the ``__call__`` method of the "
"predicate class. In other words, the ``Operators.select()`` method takes "
"as argument a functor which in turn takes an ``Interface0D`` object as "
"argument. The Freestyle Python API employs functors extensively to "
"implement predicates, as well as functions."
msgstr ""
"It is noted that ``QuantitativeInvisibilityUP1D -- "
"QuantitativeInvisibilityUP1D`` is a class implementing the predicate that"
" tests line visibility, and the ``Thao Tác.chọn() -- Operators.select()``"
" method takes an instance of the predicate class as argument. The testing"
" of the predicate for a given 1D element is actually done by calling the "
"predicate instance, that is, by invoking the ``__call__ -- __call__`` "
"method of the predicate class. In other words, the ``Thao Tác.chọn() -- "
"Operators.select()`` method takes as argument a functor which in turn "
"takes an ``Interface0D -- Interface0D`` object as argument. The Freestyle"
" Python API employs functors extensively to implement predicates, as well"
" as functions."

msgid "Chaining"
msgstr "Chuyền Nối -- Chaining"

msgid ""
"The chaining operators act on the set of active ``ViewEdge`` objects and "
"determine the topology of the future strokes. The idea is to implement an"
" iterator to traverse the ViewMap graph by marching along ViewEdges. The "
"iterator defines a chaining rule that determines the next ``ViewEdge`` to"
" follow at a given vertex (see ``ViewEdgeIterator``). Several such "
"iterators are provided as part of the Freestyle Python API (see "
"``ChainPredicateIterator`` and ``ChainSilhouetteIterator``). Custom "
"iterators can be defined by inheriting the ``ViewEdgeIterator`` class. "
"The chaining operator also takes as argument a UnaryPredicate working on "
"``Interface1D`` as a stopping criteria. The chaining stops when the "
"iterator has reached a ``ViewEdge`` satisfying this predicate during the "
"march along the graph."
msgstr ""
"The chaining operators act on the set of active ``ViewEdge -- ViewEdge`` "
"objects and determine the topology of the future strokes. The idea is to "
"implement an iterator to traverse the ViewMap graph by marching along "
"ViewEdges. The iterator defines a chaining rule that determines the next "
"``ViewEdge -- ViewEdge`` to follow at a given vertex (see "
"``ViewEdgeIterator -- ViewEdgeIterator``). Several such iterators are "
"provided as part of the Freestyle Python API (see "
"``ChainPredicateIterator -- ChainPredicateIterator`` and "
"``ChainSilhouetteIterator -- ChainSilhouetteIterator``). Custom iterators"
" can be defined by inheriting the ``ViewEdgeIterator -- "
"ViewEdgeIterator`` class. The chaining operator also takes as argument a "
"UnaryPredicate working on ``Interface1D -- Interface1D`` as a stopping "
"criteria. The chaining stops when the iterator has reached a ``ViewEdge "
"-- ViewEdge`` satisfying this predicate during the march along the graph."

msgid ""
"Chaining can be either unidirectional ``Operators.chain()`` or "
"bidirectional ``Operators.bidirectional_chain()``. In the latter case, "
"the chaining will propagate in the two directions from the starting edge."
msgstr ""
"Chaining can be either unidirectional ``Thao Tác.chain() -- "
"Operators.chain()`` or bidirectional ``Thao Tác.bidirectional_chain() -- "
"Operators.bidirectional_chain()``. In the latter case, the chaining will "
"propagate in the two directions from the starting edge."

msgid "The following is a code example of bidirectional chaining::"
msgstr "The following là a mã nguồn ví dụ của bidirectional chuyền nối::"

msgid ""
"The chaining operator uses the ``ChainSilhouetteIterator`` as the "
"chaining rule and stops chaining as soon as the iterator has come to an "
"invisible ``ViewEdge``."
msgstr ""
"The chaining operator uses the ``ChainSilhouetteIterator -- "
"ChainSilhouetteIterator`` as the chaining rule and stops chaining as soon"
" as the iterator has come to an invisible ``ViewEdge -- ViewEdge``."

msgid ""
"The chaining operators process the set of active ``ViewEdge`` objects in "
"order. The active ViewEdges can be previously sorted using the "
"``Operators.sort()`` method (see below). It starts a chain with the first"
" ``ViewEdge`` of the active set. All ViewEdges that have already been "
"involved in the chaining process are marked (in the case of the example "
"above, the time stamp of each ``ViewEdge`` is modified by default), in "
"order not to process the same ``ViewEdge`` twice. Once the chaining "
"reaches a ``ViewEdge`` that satisfies the stopping predicate, the chain "
"is terminated. Then a new chain is started from the first unmarked "
"``ViewEdge`` in the active set. This operation is repeated until the last"
" unmarked ``ViewEdge`` of the active set was processed. At the end of the"
" chaining operation, the active set is set to the Chains that have just "
"been constructed."
msgstr ""
"The chaining operators process the set of active ``ViewEdge -- ViewEdge``"
" objects in order. The active ViewEdges can be previously sorted using "
"the ``Thao Tác.sắp thứ tự() -- Operators.sort()`` method (xin xem dưới "
"đây -- see below). It starts a chain with the first ``ViewEdge -- "
"ViewEdge`` of the active set. All ViewEdges that have already been "
"involved in the chaining process are marked (in the case of the example "
"above, the time stamp of each ``ViewEdge -- ViewEdge`` is modified by "
"default), in order not to process the same ``ViewEdge -- ViewEdge`` "
"twice. Once the chaining reaches a ``ViewEdge -- ViewEdge`` that "
"satisfies the stopping predicate, the chain is terminated. Then a new "
"chain is started from the first unmarked ``ViewEdge -- ViewEdge`` in the "
"active set. This operation is repeated until the last unmarked ``ViewEdge"
" -- ViewEdge`` of the active set was processed. At the end of the "
"chaining operation, the active set is set to the Chains that have just "
"been constructed."

msgid "Splitting"
msgstr "Tách Phân -- Splitting"

msgid ""
"The splitting operation is used to refine the topology of each Chain. "
"Splitting is performed either sequentially or recursively. Sequential "
"splitting ``Operators.sequentialSplit()`` in its basic form, parses the "
"Chain at a given arbitrary resolution and evaluates a unary predicate "
"(working on 0D elements) at each point along the Chain. Every time the "
"predicate is satisfied, the chain is split into two chains. At the end of"
" the sequential split operation, the active set of chains is set to the "
"new chains. ::"
msgstr ""
"The splitting operation is used to refine the topology of each Chain. "
"Splitting is performed either sequentially or recursively. Sequential "
"splitting ``Thao Tác.sequentialSplit() -- Operators.sequentialSplit()`` "
"in its basic form, parses the Chain at a given arbitrary resolution and "
"evaluates a unary predicate (working bật 0D phần tử -- working on 0D "
"elements) at each point along the Chain. Every time the predicate is "
"satisfied, the chain is split into two chains. At the end of the "
"sequential split operation, the active set of chains is set to the new "
"chains. ::"

msgid ""
"In this example, the chain is split every 2 units. A more elaborated "
"version uses two predicates instead of one: One to determine the starting"
" point of the new chain and the other to determine its ending point. This"
" second version can lead to a set of Chains that are disjoint or that "
"overlap if the two predicates are different (see "
"``Operators.sequentialSplit()`` for more details)."
msgstr ""
"In this example, the chain is split every 2 units. A more elaborated "
"version uses two predicates instead of one: One to determine the starting"
" point of the new chain and the other to determine its ending point. This"
" second version can lead to a set of Chains that are disjoint or that "
"overlap if the two predicates are different (see ``Thao "
"Tác.sequentialSplit() -- Operators.sequentialSplit()`` for more details)."

msgid ""
"Recursive splitting ``Operators.recursiveSplit()`` evaluates a function "
"on the 0D elements along the Chain at a given resolution and find the "
"point that gives the maximum value for the function. The Chain is then "
"split into two at that point. This process is recursively repeated on "
"each of the two new Chains, until the input Chain satisfies a user-"
"specified stopping condition. ::"
msgstr ""
"Recursive splitting ``Thao Tác.recursiveSplit() -- "
"Operators.recursiveSplit()`` evaluates a function on the 0D elements "
"along the Chain at a given resolution and find the point that gives the "
"maximum value for the function. The Chain is then split into two at that "
"point. This process is recursively repeated on each of the two new "
"Chains, until the input Chain satisfies a user-specified stopping "
"condition. ::"

msgid ""
"In the code example above, the Chains are recursively split at points of "
"the highest 2D curvature. The curvature is evaluated at points along the "
"Chain at a resolution of 5 units. Chains shorter than 5 units will not be"
" split anymore."
msgstr ""
"Vào the mã nguồn ví dụ above, the Chains là đệ quy tách phân tại số điểm "
"của the cao nhất 2D curvature. The curvature là evaluated tại số điểm dọc"
" theo the Chain tại a độ phân giải của 5 đơn vị. Chains shorter than 5 "
"đơn vị sẽ đảo nghịch được/là tách phân anymore."

msgid "Sorting"
msgstr "Sắp Thứ Tự -- Sorting"

msgid ""
"The sorting operator ``Operators.sort()`` arranges the stacking order of "
"active 1D elements. It takes as argument a binary predicate used as a "
"\"smaller than\" operator to order two 1D elements. ::"
msgstr ""
"The sorting operator ``Thao Tác.sắp thứ tự() -- Operators.sort()`` "
"arranges the stacking order of active 1D elements. It takes as argument a"
" binary predicate used as a \"smaller than -- smaller than\" operator to "
"order two 1D elements. ::"

msgid ""
"In this code example, the sorting uses the ``Length2DBP1D`` binary "
"predicate to sort the ``Interface1D`` objects in the ascending order in "
"terms of 2D length."
msgstr ""
"In this code example, the sorting uses the ``Length2DBP1D -- "
"Length2DBP1D`` binary predicate to sort the ``Interface1D -- "
"Interface1D`` objects in the ascending order in terms of 2D length."

msgid ""
"The sorting is particularly useful when combined with causal density. "
"Indeed, the causal density evaluates the density of the resulting image "
"as it is modified. If we wish to use such a tool to decide to remove "
"strokes whenever the local density is too high, it is important to "
"control the order in which the strokes are drawn. In this case, we would "
"use the sorting operator to ensure that the most \"important\" lines are "
"drawn first."
msgstr ""
"The sorting is particularly useful when combined with causal density. "
"Indeed, the causal density evaluates the density of the resulting image "
"as it is modified. If we wish to use such a tool to decide to remove "
"strokes whenever the local density is too high, it is important to "
"control the order in which the strokes are drawn. In this case, we would "
"use the sorting operator to ensure that the most \"important -- "
"important\" lines are drawn first."

msgid "Stroke Creation"
msgstr "Nét Vẽ Sự Kiến Tạo -- Stroke Creation"

msgid ""
"Finally, the stroke creation operator ``Operators.create()`` takes the "
"active set of Chains as input and build Strokes. The operator takes two "
"arguments. The first is a unary predicate that works on ``Interface1D`` "
"that is designed to make a last selection on the set of chains. A Chain "
"that does not satisfy the condition will not lead to a Stroke. The second"
" input is a list of shaders that will be responsible for the shading of "
"each built stroke. ::"
msgstr ""
"Finally, the stroke creation operator ``Thao Tác.kiến tạo() -- "
"Operators.create()`` takes the active set of Chains as input and build "
"Strokes. The operator takes two arguments. The first is a unary predicate"
" that works on ``Interface1D -- Interface1D`` that is designed to make a "
"last selection on the set of chains. A Chain that does not satisfy the "
"condition will not lead to a Stroke. The second input is a list of "
"shaders that will be responsible for the shading of each built stroke. ::"

msgid ""
"In this example, the ``DensityUP1D`` predicate is used to remove all "
"Chains whose mean density is higher than 0.1. Each chain is transformed "
"into a stroke by resampling it so as to have a point every 5 units and "
"assigning to it a constant thickness of 2 units and a dark gray constant "
"color."
msgstr ""
"In this example, the ``DensityUP1D -- DensityUP1D`` predicate is used to "
"remove all Chains whose mean density is higher than 0.1. Each chain is "
"transformed into a stroke by resampling it so as to have a point every 5 "
"units and assigning to it a constant thickness of 2 units and a dark gray"
" constant color."

msgid "User Control on the Pipeline Definition"
msgstr ""
"Người Dùng Điều Khiển bật the Quy Trình Độ Phân Giải -- User Control on "
"the Pipeline Definition"

msgid ""
"Style module writing offers different types of user control, even though "
"individual style modules have a fixed pipeline structure. One is the "
"sequencing of different pipeline control structures, and another is "
"through the definition of functor objects that are passed as argument all"
" along the pipeline."
msgstr ""
"Kiểu mô-đun viết/ghi offers khác thể loại của người dùng điều khiển, đều "
"đặn though cá nhân kiểu modules có a cố định/bất biến/định trước quy "
"trình cấu trúc. Một là the sequencing của khác quy trình điều khiển "
"structures, và một cái/điều khác là through the độ phân giải của functor "
"vật thể đó/mà là passed tựa như argument toàn bộ dọc theo the quy trình."

msgid ""
"Different pipeline control structures can be defined by sequencing the "
"selection, chaining, splitting, and sorting operations. The stroke "
"creation is always the last operation that concludes a style module."
msgstr ""
"Khác quy trình điều khiển structures có thể được/là defined bằng cách "
"sequencing the lựa chọn, chuyền nối, tách phân, và sắp thứ tự các thao "
"tác. The nét vẽ sự kiến tạo là luôn luôn the cuối thao tác đó/mà "
"concludes a kiểu mô-đun."

msgid ""
"Predicates, functions, chaining iterators, and stroke shaders can be "
"defined by inheriting base classes and overriding appropriate methods. "
"See the reference manual entries of the following base classes for more "
"information on the user-scriptable constructs."
msgstr ""
"Predicates, các hàm, chuyền nối iterators, và nét vẽ bộ tô bóng có thể "
"được/là defined bằng cách inheriting cơ sở classes và overriding "
"appropriate methods. Xin Xem the tham chiếu thủ công/sách hướng dẫn sử "
"dụng entries của the following cơ sở classes dành cho/đối với/để "
"nhiều/lớn hơn thông tin bật the user-scriptable các cấu trúc."

msgid ""
"Predicates, functions, chaining iterators, and stroke shaders can be "
"defined by inheriting base classes and overriding appropriate methods. "
"See :mod:`Freestyle python module <blender_api:freestyle>` for more "
"information on the user-scriptable constructs."
msgstr ""
"Predicates, functions, chaining iterators, and stroke shaders can be "
"defined by inheriting base classes and overriding appropriate methods. "
"See :mod:`Phong Cách Tự Do python mô-đun -- Freestyle python module "
"<blender_api:freestyle>` for more information on the user-scriptable "
"constructs."

