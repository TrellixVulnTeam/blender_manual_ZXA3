<document source="/home/htran/blender_documentations/blender_docs/manual/editors/texture_node/types/converter/math.rst">
 <target ids="['bpy-types-texturenodemath']" names="['bpy.types.texturenodemath']">
 </target>
 <comment xml:space="preserve">
  DO NOT EDIT FILE. This is simply a stub which copies everything from the link below.
 </comment>
 <section ids="math-node" names="math\ node">
  <title>
   Math Node
  </title>
  <figure align="right" ids="id1">
   <image candidates="{'*': 'images/compositing_node-types_CompositorNodeMath.png'}" uri="images/compositing_node-types_CompositorNodeMath.png"/>
   <caption>
    Math node.
   </caption>
  </figure>
  <paragraph>
   The
   <emphasis>
    Math Node
   </emphasis>
   performs math operations.
  </paragraph>
  <section ids="inputs" names="inputs">
   <title>
    Inputs
   </title>
   <definition_list>
    <definition_list_item>
     <term>
      Value
     </term>
     <definition>
      <paragraph>
       First numerical value. The trigonometric functions accept values in radians.
      </paragraph>
     </definition>
    </definition_list_item>
    <definition_list_item>
     <term>
      Value
     </term>
     <definition>
      <paragraph>
       Second numerical value.
This value is
       <strong>
        not
       </strong>
       used in functions that accept only one parameter
like the trigonometric functions, Round and Absolute.
      </paragraph>
     </definition>
    </definition_list_item>
   </definition_list>
  </section>
  <section ids="properties" names="properties">
   <title>
    Properties
   </title>
   <definition_list>
    <definition_list_item>
     <term>
      Operation
     </term>
     <definition>
      <paragraph>
       Add, Subtract, Multiply, Divide, Sine, Cosine, Tangent, Arcsine, Arccosine, Arctangent, Arctangent2,
Power, Logarithm, Minimum, Maximum, Round, Less Than, Greater Than, Modulo, Absolute
      </paragraph>
     </definition>
    </definition_list_item>
    <definition_list_item>
     <term>
      Clamp
     </term>
     <definition>
      <paragraph>
       Limits the output to the range (0 to 1). See
       <reference internal="True" refuri="#term-clamp">
        <inline classes="xref std std-term">
         clamp
        </inline>
       </reference>
       .
      </paragraph>
     </definition>
    </definition_list_item>
   </definition_list>
  </section>
  <section ids="outputs" names="outputs">
   <title>
    Outputs
   </title>
   <definition_list>
    <definition_list_item>
     <term>
      Value
     </term>
     <definition>
      <paragraph>
       Numerical value output.
      </paragraph>
     </definition>
    </definition_list_item>
   </definition_list>
  </section>
  <section ids="examples" names="examples">
   <title>
    Examples
   </title>
   <section ids="manual-z-mask" names="manual\ z-mask">
    <title>
     Manual Z-Mask
    </title>
    <figure ids="id2">
     <image candidates="{'*': 'images/compositing_types_converter_math_manual-z-mask.png'}" uri="images/compositing_types_converter_math_manual-z-mask.png"/>
     <caption>
      Minimum and maximum function example.
     </caption>
    </figure>
    <paragraph>
     This example has one scene input by the top
     <emphasis>
      Render Layers
     </emphasis>
     node,
which has a cube that is about 10 units from the camera.
The bottom
     <emphasis>
      Render Layers
     </emphasis>
     node inputs a scene
with a plane that covers the left half of the view and is 7 units from the camera.
Both are fed through their respective
     <emphasis>
      Map Value
     </emphasis>
     nodes to divide the Z-buffer by 20
(multiply by 0.05, as shown in the Size field)
and clamped to be a min/max of 0.0/1.0 respectively.
    </paragraph>
    <paragraph>
     For the minimum function,
the node selects those Z values where the corresponding pixel is closer to the camera;
so it chooses the Z values for the plane and part of the cube.
The background has an infinite Z value, so it is clamped to 1.0 (shown as white).
In the maximum example, the Z values of the cube are greater than the plane,
so they are chosen for the left side, but the plane
     <emphasis>
      Render Layers
     </emphasis>
     Z are infinite
(mapped to 1.0) for the right side, so they are chosen.
    </paragraph>
   </section>
   <section ids="using-sine-function-to-pulsate" names="using\ sine\ function\ to\ pulsate">
    <title>
     Using Sine Function to Pulsate
    </title>
    <figure ids="id3">
     <image candidates="{'*': 'images/compositing_types_converter_math_sine.png'}" uri="images/compositing_types_converter_math_sine.png"/>
     <caption>
      Using sine function example.
     </caption>
    </figure>
    <paragraph>
     This example has a
     <emphasis>
      Time
     </emphasis>
     node putting out a linear sequence from 0 to 1 over the course of 101 frames.
At frame 25, the output value is 0.25.
That value is multiplied by 2 × pi (6.28) and converted to 1.0 by the Sine function,
since we all know that
     <math>
      sin(2 × pi/ 4) = sin(pi/ 2) = +1.0
     </math>
     .
    </paragraph>
    <paragraph>
     Since the sine function can put out values between (-1.0 to 1.0),
the
     <emphasis>
      Map Value
     </emphasis>
     node scales that to 0.0 to 1.0 by taking the input (-1 to 1), adding 1
(making 0 to 2), and multiplying the result by one-half (thus scaling the output between 0 to 1).
The default
     <emphasis>
      Color Ramp
     </emphasis>
     converts those values to a gray-scale.
Thus, medium gray corresponds to a 0.0 output by the sine, black to -1.0,
and white to 1.0. As you can see,
     <math>
      sin(pi/ 2) = 1.0
     </math>
     . Like having your own visual color calculator!
Animating this node setup provides a smooth cyclic sequence through the range of grays.
    </paragraph>
    <paragraph>
     Use this function to vary, for example,
the alpha channel of an image to produce a fading in/out effect.
Alter the Z channel to move a scene in/out of focus.
Alter a color channel value to make a color “pulse”.
    </paragraph>
   </section>
   <section ids="brightening-scaling-a-channel" names="brightening\ (scaling)\ a\ channel">
    <title>
     Brightening (Scaling) a Channel
    </title>
    <figure ids="id4">
     <image candidates="{'*': 'images/compositing_types_converter_math_multiply.png'}" uri="images/compositing_types_converter_math_multiply.png"/>
     <caption>
      Scaling a channel example.
     </caption>
    </figure>
    <paragraph>
     This example has a
     <emphasis>
      Math (Multiply)
     </emphasis>
     node increasing the luminance channel (Y)
of the image to make it brighter. Note that you should use a
     <emphasis>
      Map Value node
     </emphasis>
     with min() and max() enabled to clamp the output to valid values.
With this approach, you could use a logarithmic function to make a high dynamic range image.
For this particular example,
there is also a
     <emphasis>
      Bright/Contrast node
     </emphasis>
     that might give simpler control over brightness.
    </paragraph>
   </section>
   <section ids="restrict-color-selection-posterization" names="restrict\ color\ selection\ (posterization)">
    <title>
     Restrict Color Selection (Posterization)
    </title>
    <figure ids="id5">
     <image candidates="{'*': 'images/compositing_types_converter_math_posterization.png'}" uri="images/compositing_types_converter_math_posterization.png"/>
     <caption>
      Posterization example.
     </caption>
    </figure>
    <paragraph>
     In this example, we restrict the color values to be one of the six values: 0, 0.2, 0.4, 0.6, 0.8, 1.
    </paragraph>
    <paragraph>
     To split up a continuous range of values between 0 and 1 to certain set of values,
the following function is used:
     <math>
      round(x × n - 0.5) / (n - 1)
     </math>
     ,
where “n” is the number of possible output values, and “x” is the input pixel color.
     <reference name="Read more about this function" refuri="https://en.blender.org/index.php/Doc:2.4/Manual/Composite_Nodes/Types/Convertor#Quantize.2FRestrict_Color_Selection">
      Read more about this function
     </reference>
     .
    </paragraph>
    <paragraph>
     To implement this function in Blender, consider the node setup above.
We string the Math nodes into a function that takes each color (values from 0 to 1),
multiplies it up by six, the desired number of divisions (values become from 0 to 6),
offsets it by 0.5 (-0.5 to 5.5),
rounds the value to the nearest whole number (produces 0, 1, 2, 3, 4, 5),
and then divides the image pixel color by five (0.0, 0.2, 0.4, 0.6, 0.8, 1.0).
    </paragraph>
    <paragraph>
     In the case of a color image,
you need split it into separate RGB channels using
     <emphasis>
      Separate/Combine RGBA
     </emphasis>
     nodes
and perform this operation on each channel independently.
    </paragraph>
   </section>
  </section>
 </section>
</document>